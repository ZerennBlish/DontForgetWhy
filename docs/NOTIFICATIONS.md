# Notification System

> Complete notification lifecycle reference. Read this before touching anything in notifications.ts, alarmSound.ts, pendingAlarm.ts, index.ts, or App.tsx event handlers. Updated Feb 2026.

---

## Table of Contents

1. [Channel IDs and Configuration](#1-channel-ids-and-configuration)
2. [Channel Creation: Native vs JavaScript](#2-channel-creation-native-vs-javascript)
3. [Audio System: MediaPlayer, NOT Channel Audio](#3-audio-system-mediaplayer-not-channel-audio)
4. [Sound Playback Flow](#4-sound-playback-flow)
5. [Screen-Off Behavior](#5-screen-off-behavior)
6. [Screen-On Behavior](#6-screen-on-behavior)
7. [DND Bypass](#7-dnd-bypass)
8. [Event Types: DELIVERED, PRESS, DISMISSED](#8-event-types-delivered-press-dismissed)
9. [Foreground vs Background Event Handling](#9-foreground-vs-background-event-handling)
10. [Timer vs Alarm Notification Differences](#10-timer-vs-alarm-notification-differences)
11. [Snooze Flow](#11-snooze-flow)
12. [Samsung-Specific: DND and Full-Screen Intent](#12-samsung-specific-dnd-and-full-screen-intent)
13. [Legacy Channel Migration](#13-legacy-channel-migration)
14. [Reminder Notifications](#14-reminder-notifications)
15. [Sound Preview](#15-sound-preview)

---

## 1. Channel IDs and Configuration

### Preset Alarm Channels

All alarm channels are **SILENT** — no sound property. Sound plays via native MediaPlayer (see section 3).

| Channel ID | Name | Importance | Vibration | Light | DND Bypass |
|-----------|------|-----------|-----------|-------|------------|
| `alarms_v5` | Alarms | HIGH | [300, 300] | #FF0000 | YES |
| `alarms_gentle_v4` | Alarms (Gentle) | DEFAULT | [100, 200] | #FFD700 | YES |
| `alarms_urgent_v4` | Alarms (Urgent) | HIGH | [250,250,250,250,250,250] | #FF0000 | YES |
| `alarms_classic_v4` | Alarms (Classic) | HIGH | [300, 300, 300, 300] | #FF6600 | YES |
| `alarms_digital_v4` | Alarms (Digital) | HIGH | [100, 100, 100, 100] | #00FF00 | YES |
| `alarms_silent_v4` | Alarms (Silent) | LOW | [500, 500] | #808080 | YES |

### Utility Channels

| Channel ID | Name | Importance | Sound | Vibration | DND Bypass |
|-----------|------|-----------|-------|-----------|------------|
| `timer-progress` | Timer Progress | DEFAULT | none | NO | NO |
| `reminders` | Reminders | DEFAULT | `'default'` | YES | NO |

### Dynamic Channels

| Pattern | Purpose |
|---------|---------|
| `alarm_v2_custom_{mediaId}` | Custom alarm sound (created via `getOrCreateSoundChannel()`) |
| `timer_v2_custom_{mediaId}` | Custom timer sound (created via `getOrCreateSoundChannel()`) |
| `preview_{mediaId}` | Sound preview (created via `previewSystemSound()`) |

Defined in: `src/services/notifications.ts` lines 18-20 (constants), 126-212 (channel creation), 229-267 (dynamic channels).

---

## 2. Channel Creation: Native vs JavaScript

### Why Two Systems?

Android notification channels are **immutable after first creation**. Whichever code creates a channel first wins — later calls with the same ID are no-ops. We exploit this:

1. **Native creates first** (in `MainApplication.onCreate()` before any JS runs)
2. **JS creates second** (in `setupNotificationChannel()` as a fallback no-op)

### Native Channel Creation (PRIMARY)

**File**: `plugins/withAlarmChannel.js` → generates `AlarmChannelHelper.java`

**Called from**: `MainApplication.onCreate()` → `AlarmChannelHelper.createPresetChannels(this)`

**What it does**:
- Deletes 18 legacy channels (see section 13)
- Creates all 6 preset channels with `AudioAttributes.USAGE_ALARM`
- Sets `ch.setSound(null, ALARM_AUDIO)` — null sound, ALARM audio attributes
- Each channel gets: vibration pattern, light color, `setBypassDnd(true)`

**Key code** (`AlarmChannelHelper.java`, generated by plugin):
```java
private static final AudioAttributes ALARM_AUDIO = new AudioAttributes.Builder()
    .setUsage(AudioAttributes.USAGE_ALARM)
    .setContentType(AudioAttributes.CONTENT_TYPE_MUSIC)
    .build();

// Each channel:
ch.setSound(null, ALARM_AUDIO);  // Silent channel
ch.enableVibration(true);
ch.setBypassDnd(true);
```

### JavaScript Channel Creation (FALLBACK)

**File**: `src/services/notifications.ts` → `setupNotificationChannel()` (line 84)

**Called from**: `App.tsx` useEffect (line 327)

**What it does**:
- Singleton: `_channelPromise` ensures it runs only once
- Deletes same 18 legacy channels
- Calls `notifee.createChannel()` for each preset — these are **no-ops** when native channels already exist
- Creates `timer-progress` and `reminders` channels (these are NOT created natively)

**Why keep the JS fallback?** If the native module isn't registered for some reason, JS channels still get created. They won't have `USAGE_ALARM` audio attributes, but the app still functions (sound plays via MediaPlayer regardless).

### Dynamic Channel Creation at Runtime

**Function**: `getOrCreateSoundChannel()` (`notifications.ts` line 229)

**Called when**: User saves an alarm/timer with a custom system sound.

**Two-step process**:
1. Native: `NativeModules.AlarmChannelModule.createSoundChannel(channelId, name, soundUri)` — creates with USAGE_ALARM
2. JS fallback: `notifee.createChannel()` with HIGH importance, DND bypass, vibration — no-op if native succeeded

**Channel ID format**: `{prefix}{mediaId}` where:
- `prefix` = `'alarm_v2_custom_'` or `'timer_v2_custom_'`
- `mediaId` = numeric ID from URI (`content://media/.../1234` → `1234`) or hash of URI string

---

## 3. Audio System: MediaPlayer, NOT Channel Audio

### The Problem

Notifee v9.x **does not expose `audioAttributes`** in its JavaScript channel creation API. If you set `sound` on a Notifee channel, it routes through the **notification audio stream**, which:
- Respects ringer mode (no sound in silent/vibrate)
- Respects DND (no sound)
- Is NOT what an alarm app needs

### The Solution

All notification channels are **SILENT** (no sound property). Audio is played independently via a native `MediaPlayer` with explicit `AudioAttributes.USAGE_ALARM`:

```
Notification provides: full-screen intent, vibration, lights, DND bypass
MediaPlayer provides: alarm sound through alarm audio stream
```

### Implementation

**Native side** (`AlarmChannelHelper.java`, generated by `plugins/withAlarmChannel.js`):

```java
public static void playSound(Context context, String soundUri) {
    stopSound();  // Stop any existing playback
    Uri uri;
    if (soundUri != null && !soundUri.isEmpty()) {
        uri = Uri.parse(soundUri);  // Custom sound
    } else {
        // Fallback: raw/alarm resource → system alarm ringtone
        int rawId = context.getResources().getIdentifier("alarm", "raw", context.getPackageName());
        uri = rawId != 0
            ? Uri.parse("android.resource://" + context.getPackageName() + "/raw/alarm")
            : RingtoneManager.getDefaultUri(RingtoneManager.TYPE_ALARM);
    }
    sPlayer = new MediaPlayer();
    sPlayer.setAudioAttributes(ALARM_AUDIO);  // USAGE_ALARM
    sPlayer.setDataSource(context, uri);
    sPlayer.setLooping(true);
    sPlayer.prepare();
    sPlayer.start();
}
```

**JS bridge** (`src/services/alarmSound.ts`):

| Function | What it does |
|----------|-------------|
| `playAlarmSound(soundUri)` | Calls `NativeModules.AlarmChannelModule.playAlarmSound(soundUri)`, sets `_playing = true` |
| `stopAlarmSound()` | Calls `NativeModules.AlarmChannelModule.stopAlarmSound()`, sets `_playing = false` |
| `playAlarmSoundForNotification(alarmId?, timerId?)` | Resolves correct URI and calls `playAlarmSound()` |
| `isAlarmSoundPlaying()` | Returns module-level `_playing` flag |

### Sound Resolution in `playAlarmSoundForNotification()`

```
If timerId:
  → getDefaultTimerSound() → playAlarmSound(timerSound.uri)
If alarmId:
  → loadAlarms() → find alarm → check soundId
  → If 'silent': return (no sound, vibration only)
  → Else: playAlarmSound(alarm.soundUri ?? null)
If neither:
  → playAlarmSound(null)  // uses system alarm ringtone
```

---

## 4. Sound Playback Flow

### Step by step (alarm fires):

1. **Notifee trigger fires** — Android AlarmManager delivers the notification
2. **DELIVERED event** fires in JS
3. **Background handler** (`index.ts` line 82-83):
   ```typescript
   if (type === EventType.DELIVERED && (alarmId || timerId)) {
     playAlarmSoundForNotification(alarmId, timerId).catch(() => {});
   }
   ```
4. **`playAlarmSoundForNotification()`** (`alarmSound.ts` line 44):
   - Loads alarm from AsyncStorage
   - If `soundId === 'silent'`: returns early (no sound)
   - Otherwise: calls `playAlarmSound(alarm.soundUri ?? null)`
5. **`playAlarmSound()`** → `NativeModules.AlarmChannelModule.playAlarmSound(soundUri)`
6. **Java `AlarmChannelHelper.playSound()`**:
   - Stops any existing player
   - Resolves URI (custom sound → raw resource → system alarm ringtone)
   - Creates MediaPlayer with `USAGE_ALARM` AudioAttributes
   - Sets looping = true
   - Starts playback

### Sound stops when:

- **User taps Dismiss**: `AlarmFireScreen.handleDismiss()` → `cancelAllNotifications()` → `stopAlarmSound()`
- **User taps Snooze**: `AlarmFireScreen.handleSnooze()` → `cancelAllNotifications()` → `stopAlarmSound()`
- **User taps Guess Why**: `AlarmFireScreen.handleGuessWhy()` → `cancelAllNotifications()` → `stopAlarmSound()`
- **User swipes notification**: DISMISSED event → `stopAlarmSound()` (both handlers)
- **AlarmFireScreen unmounts**: cleanup in useEffect return → `stopAlarmSound()`

### AlarmFireScreen sound fallback (`AlarmFireScreen.tsx` line 114):

If the event handlers didn't start sound (e.g., different JS context on cold start), AlarmFireScreen has a fallback:
```typescript
useEffect(() => {
  if (!fromNotification || postGuessWhy) return;
  if (!isTimer && alarm?.soundId === 'silent') return;
  if (isAlarmSoundPlaying()) return;  // Already playing
  // Resolve URI and play
  playAlarmSound(soundUri);
  return () => stopAlarmSound();  // Cleanup on unmount
}, []);
```

---

## 5. Screen-Off Behavior

When the device screen is off and an alarm fires:

1. **Notifee fires `fullScreenAction`** — the notification includes:
   ```typescript
   fullScreenAction: { id: 'default', launchActivity: 'default' }
   ```
   This tells Android to launch `MainActivity` as a full-screen intent.

2. **MainActivity.onCreate() runs** (injected by `plugins/withAlarmWake.js`):
   ```kotlin
   // Show activity over lock screen
   if (Build.VERSION.SDK_INT >= 27) {
     setShowWhenLocked(true)
     setTurnScreenOn(true)
   }
   // Keep screen on
   window.addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)
   // Dismiss lock pattern/PIN
   if (Build.VERSION.SDK_INT >= 26) {
     val keyguardManager = getSystemService(KEYGUARD_SERVICE) as? KeyguardManager
     keyguardManager?.requestDismissKeyguard(this, null)
   }
   ```

3. **Background handler fires** (`index.ts`):
   - Plays alarm sound immediately via `playAlarmSoundForNotification()`
   - Stores pending alarm data via `setPendingAlarm()`

4. **App mounts** → init phase (`App.tsx` line 214):
   - Reads `getPendingAlarm()` — finds pending data
   - Creates `initialState` with AlarmList at index 0, AlarmFire at index 1
   - Marks notification as handled in dedupe map

5. **AlarmFireScreen renders immediately** — no flash of AlarmListScreen.

---

## 6. Screen-On Behavior

When the device is unlocked and the app is in foreground:

1. **Heads-up notification** appears (HIGH importance → popup at top)
2. **Foreground handler fires** (`App.tsx` line 392):
   - Receives `EventType.DELIVERED`
   - Calls `playAlarmSoundForNotification()` — sound starts
   - Checks dedupe map and navigation state
   - Navigates to AlarmFireScreen via `navigationRef.current.navigate()`

When the app is in background (but not killed):

1. **DELIVERED event fires** in foreground handler (it still runs)
2. If navigation not ready → stores as pending via `setPendingAlarm()`
3. **AppState listener** catches `'active'` transition → calls `consumePendingAlarm()` → navigates

---

## 7. DND Bypass

DND bypass works at two levels:

### Channel Level
All alarm channels set `bypassDnd: true` (both native and JS creation):
```java
// Native (AlarmChannelHelper.java)
ch.setBypassDnd(true);
```
```typescript
// JS (notifications.ts)
bypassDnd: true,
```
This ensures the **notification itself** (vibration, lights, full-screen intent) works even in DND mode.

### Audio Level
`AudioAttributes.USAGE_ALARM` routes audio through the **alarm audio stream**, which:
- **Ignores ringer mode** (plays in silent/vibrate)
- **Ignores DND** (alarm stream is exempt)
- Uses the device's **alarm volume** (separate from notification volume)

### Reminder Channel: No DND Bypass
The `reminders` channel does NOT bypass DND:
```typescript
// notifications.ts line 206-212
await notifee.createChannel({
  id: REMINDER_CHANNEL_ID,
  name: 'Reminders',
  importance: AndroidImportance.DEFAULT,
  sound: 'default',  // Uses notification stream
  vibration: true,
  // NO bypassDnd
});
```

---

## 8. Event Types: DELIVERED, PRESS, DISMISSED

### EventType.DELIVERED (3)

**Fires when**: Notification is displayed by the system. For scheduled triggers with `fullScreenAction`, this fires when the alarm goes off and the full-screen intent launches.

**NOT the same as** `TRIGGER_NOTIFICATION_CREATED` (7), which fires when the trigger is *scheduled*, not when it fires.

**What happens**:
- **Background handler** (`index.ts` line 82): Plays alarm sound, stores pending data
- **Foreground handler** (`App.tsx` line 413): Filters for alarm/timer only (skips reminders, previews), plays sound, navigates to AlarmFireScreen

### EventType.PRESS (1)

**Fires when**: User taps the notification in the notification shade or taps the heads-up popup.

**What happens**:
- **Background handler** (`index.ts` line 79): Stores pending alarm data (same as DELIVERED)
- **Foreground handler** (`App.tsx` line 401): Navigates to AlarmFireScreen

### EventType.DISMISSED (0)

**Fires when**: User swipes away the notification, or app calls `notifee.cancelNotification()`.

**What happens** (same in both handlers):
1. `stopAlarmSound()` — stops MediaPlayer
2. If alarmId and alarm is one-time → `deleteAlarm(alarmId)` (soft delete) + `refreshTimerWidget()`

### EventType.TRIGGER_NOTIFICATION_CREATED (7)

**Explicitly NOT handled**. Comment in `App.tsx` line 389:
```typescript
// Do NOT handle TRIGGER_NOTIFICATION_CREATED (7) here — that fires
// when a trigger is SCHEDULED, not when the alarm actually goes off.
```

---

## 9. Foreground vs Background Event Handling

### Background Handler (`index.ts` line 73)

```typescript
notifee.onBackgroundEvent(async ({ type, detail }) => { ... });
```

**Context**: Runs in headless JS (no React tree). App may be killed or in background. Registered before `registerRootComponent()`.

**Responsibilities**:
1. Play alarm sound on DELIVERED
2. Store pending alarm/timer data in module-level variable (`setPendingAlarm()`)
3. Stop sound and soft-delete one-time alarms on DISMISSED
4. Reschedule yearly reminders on DELIVERED/DISMISSED

**How pending data reaches AlarmFireScreen**:
- Module-level `_pending` variable is readable by `App.tsx` init phase
- Data survives because background handler and React app share the same JS context
- Init phase reads synchronously during first render

### Foreground Handler (`App.tsx` line 392)

```typescript
const unsubscribe = notifee.onForegroundEvent(async ({ type, detail }) => { ... });
```

**Context**: Runs when app is open. React tree mounted. Navigation available.

**Responsibilities**:
1. Play alarm sound on DELIVERED (for alarm/timer completion only)
2. Navigate to AlarmFireScreen on PRESS or DELIVERED
3. If navigation not ready → store as pending for `onNavigationReady` or AppState
4. Stop sound and soft-delete one-time alarms on DISMISSED
5. Reschedule yearly reminders on DELIVERED/DISMISSED

**Key difference from background**: Can navigate directly via `navigationRef.current.navigate()`.

### Deduplication Flow

A single notification can fire events in multiple places. The dedupe system prevents double navigation:

```
1. Background handler fires → setPendingAlarm() + markNotifHandled(notifId)
2. App mounts → init reads pending → markNotifHandled(notifId) → renders AlarmFireScreen
3. Foreground handler fires → wasNotifHandled(notifId) → true → SKIPS
4. AppState listener fires → consumePendingAlarm() → getPendingAlarm() → null → SKIPS
```

**Dedupe map**: `_handledNotifs: Map<string, number>` in `pendingAlarm.ts`
- Key: notification ID
- Value: timestamp when handled
- TTL: 10 minutes (`HANDLED_TTL = 600_000`)
- Cleaned up on each `markNotifHandled()` call

### Init Phase (`App.tsx` line 214)

Runs once on mount. Handles TRUE cold start:

1. Check `getPendingAlarm()` — module-level data from background handler
2. If found → build `alarmFireParams` → mark as handled
3. Fallback: `notifee.getInitialNotification()` — catches PRESS/fullScreenAction cold start
4. If found and not already handled → build `alarmFireParams` → mark as handled
5. Set `initState` → navigator renders with AlarmFireScreen as initial route

### onNavigationReady (`App.tsx` line 521)

Fires when `NavigationContainer` becomes ready. Catches pending data that wasn't consumed by init (e.g., app was already running):
```typescript
const pending = getPendingAlarm();
if (pending) {
  clearPendingAlarm();
  navigateToAlarmFire(pending);
}
```

### AppState Fallback (`App.tsx` line 541)

Watches for `'active'` state. Catches edge cases where foreground handler missed the event:
```typescript
AppState.addEventListener('change', (state) => {
  if (state === 'active' && isNavigationReady.current) {
    consumePendingAlarm();
  }
});
```

`consumePendingAlarm()` also has a **displayed notification fallback**: if no pending data exists, it checks `notifee.getDisplayedNotifications()` for active alarm/timer notifications that haven't been handled yet.

---

## 10. Timer vs Alarm Notification Differences

### Two Notification IDs for Timers

Timers create **two separate notifications**:

| Notification | ID Format | Channel | Has Data | Purpose |
|-------------|-----------|---------|----------|---------|
| Countdown | `countdown-{timerId}` | `timer-progress` | NO | Silent ongoing chronometer |
| Completion | `timer-done-{timerId}` | `alarms_v5` (or custom) | `{ timerId }` | Fire alarm when timer done |

**Why separate IDs?** Comment in `notifications.ts` lines 499-503:
```
Sharing an ID caused Android to treat the completion as an "update"
to the silent countdown notification, suppressing the alarm sound.
A distinct ID fires as a brand-new HIGH-importance notification
with full-screen action and sound.
```

### How Event Handlers Distinguish Them

The countdown notification has **no data field**, so `detail.notification.data.timerId` is `undefined`. The completion notification has `data: { timerId }`.

```typescript
// This is ONLY true for completion notifications:
const timerId = detail.notification?.data?.timerId as string | undefined;
if (timerId) {
  // Timer COMPLETION — play sound, navigate
}
// Countdown updates produce timerId=undefined → skipped
```

### Timer Sound

Timers always use the default timer sound (from `getDefaultTimerSound()` in `settings.ts`), not alarm-specific sounds. This is resolved in:
- `playAlarmSoundForNotification()` (`alarmSound.ts` line 50-53)
- `AlarmFireScreen` sound fallback (`AlarmFireScreen.tsx` line 124-128)

### Timer Cancellation

On dismiss, both notifications must be cancelled (`AlarmFireScreen.tsx` lines 176-184):
```typescript
if (isTimer) {
  cancelTimerNotification(timerNotificationId);      // timer-done-{id}
  cancelTimerCountdownNotification(timerId);          // countdown-{id}
}
```

### Timer AlarmFireScreen Differences

When `isTimer: true`:
- Shows "Timer Complete" instead of time
- Uses `timerIcon` and `timerLabel` from notification title/body
- No Snooze button
- No Guess Why button

---

## 11. Snooze Flow

### Step by step (`AlarmFireScreen.tsx` line 238):

1. **User taps Snooze** → `handleSnooze()` called
2. **Cancel everything**: `cancelAllNotifications()` → `Vibration.cancel()` + `stopAlarmSound()` + cancel all notification IDs
3. **Schedule snooze**: `scheduleSnooze(alarm, 5)` → creates new trigger notification 5 minutes from now
   - Same channel, same fullScreenAction, same payload
   - `data: { alarmId: alarm.id }` preserved
4. **Persist snooze notification ID**: `updateSingleAlarm()` appends new ID to `notificationIds`
   - Ensures snooze notification is cancelled if alarm is disabled/deleted while snoozed
5. **Increment snooze count**: `incrementSnoozeCount(alarm.id)` → AsyncStorage `snoozeCount_{alarmId}`
6. **Show shame message**: `getSnoozeMessage(count)` → tier-based escalating roast (7 messages per tier)
7. **Animate message** for 3.5 seconds
8. **Exit to lock screen**: `navigation.reset()` → `BackHandler.exitApp()` after 100ms

### `scheduleSnooze()` (`notifications.ts` line 405):

```typescript
export async function scheduleSnooze(alarm: Alarm, minutes = 5): Promise<string> {
  const trigger: TimestampTrigger = {
    type: TriggerType.TIMESTAMP,
    timestamp: Date.now() + minutes * 60 * 1000,
    alarmManager: { allowWhileIdle: true },
  };
  // Same notification config as original alarm (channel, fullScreen, vibration)
  return await notifee.createTriggerNotification({ ... }, trigger);
}
```

### Snooze count reset

Snooze count is reset on **Dismiss** only (`AlarmFireScreen.handleDismiss()` line 222):
```typescript
if (alarm?.id) {
  await resetSnoozeCount(alarm.id);  // AsyncStorage.removeItem
}
```

---

## 12. Samsung-Specific: DND and Full-Screen Intent

### Samsung DND Blocking

Samsung One UI blocks alarm apps during Do Not Disturb **by default**. Even with `bypassDnd: true` on channels and `USAGE_ALARM` on MediaPlayer, Samsung may still suppress notifications unless the app is explicitly allowed.

**Onboarding slide** (`OnboardingScreen.tsx` line 237):
- Shown **only on Samsung devices** (detected via `Device.brand` or `Device.manufacturer`)
- Title: "One More Samsung Thing"
- Instructions:
  1. Open Settings app
  2. Tap Notifications
  3. Tap Do Not Disturb
  4. Scroll to App notifications
  5. Find Don't Forget Why and turn ON
- Button: opens `android.settings.ZEN_MODE_SETTINGS` intent
- Fallback text: "Can't find it? Your alarms will still work normally. They just won't break through Do Not Disturb mode."

### Full-Screen Intent Permission (Android 14+)

On Android 14 (API 34+), `USE_FULL_SCREEN_INTENT` became a special permission that can be revoked by the system or user. It may also be **reset on fresh install** on some Samsung devices.

**`fullScreenPermission.ts`**:
```typescript
export async function canUseFullScreenIntent(): Promise<boolean> {
  if (Platform.OS !== 'android') return true;
  if ((Platform.Version as number) < 34) return true;
  // On API 34+ we cannot verify without a native module — assume needs setup
  return false;
}
```

Conservative approach: always returns `false` on API 34+ to prompt the user during onboarding. No native module exists to call `NotificationManager.canUseFullScreenIntent()`.

**Onboarding slide** (`OnboardingScreen.tsx` line 261):
- Shown on Android only
- Instructions to enable in Settings → Apps → Special app access → Full screen notifications
- Button: `openFullScreenIntentSettings()` → `android.settings.MANAGE_APP_USE_FULL_SCREEN_INTENT`

**SettingsScreen.tsx** also checks full-screen intent status and shows a permission banner if not granted.

**Fresh install resets permission**: On Samsung devices, installing a new build (including EAS development builds) resets the full-screen intent permission. This is a dev/testing concern only — Play Store updates preserve the permission. During development, re-enable after every new build install: Settings → Apps → Don't Forget Why → Notifications → Allow full-screen intents.

---

## 13. Legacy Channel Migration

### Why Multiple Versions?

Android notification channels are **immutable after creation**. To change properties (vibration pattern, DND bypass, sound), you must create a new channel with a different ID and delete the old one.

### Channels Deleted on Every Startup

Both native (`AlarmChannelHelper.createPresetChannels()`) and JS (`_createChannels()`) delete these:

```
alarms, alarms_v2, alarms_v3, alarms_v4
alarms_gentle, alarms_gentle_v2, alarms_gentle_v3
alarms_urgent, alarms_urgent_v2, alarms_urgent_v3
alarms_classic, alarms_classic_v2, alarms_classic_v3
alarms_digital, alarms_digital_v2, alarms_digital_v3
alarms_silent, alarms_silent_v2, alarms_silent_v3
```

Total: 18 legacy channels. Deletion is safe on fresh installs (Notifee/Android silently ignores non-existent channels).

### Current Channels

After deletion, the current channels are created:
- `alarms_v5` (was `alarms_v4`)
- `alarms_gentle_v4` (was `alarms_gentle_v3`)
- `alarms_urgent_v4` (was `alarms_urgent_v3`)
- `alarms_classic_v4` (was `alarms_classic_v3`)
- `alarms_digital_v4` (was `alarms_digital_v3`)
- `alarms_silent_v4` (was `alarms_silent_v3`)

### Migration Impact

Users upgrading from old versions lose any **custom notification settings** they made for the old channels (e.g., changing vibration in system settings). This is acceptable because:
1. Most users don't customize channels in system settings
2. The new channels have better defaults (USAGE_ALARM, DND bypass)
3. Old channels without USAGE_ALARM would have broken silent-mode playback

---

## 14. Reminder Notifications

### Key Differences from Alarms

| Aspect | Alarm | Reminder |
|--------|-------|---------|
| Channel | `alarms_v5` (or custom) | `reminders` |
| Sound | MediaPlayer (USAGE_ALARM) | System default (notification stream) |
| DND bypass | YES | NO |
| Full-screen action | YES | NO |
| Importance | HIGH | DEFAULT |
| Category | `AndroidCategory.ALARM` | Not set |

### Scheduling Scenarios (`notifications.ts` line 572)

1. **Weekly specific days**: One trigger per day with `RepeatFrequency.WEEKLY`
   - `skipCurrentCycle`: if today's trigger already passed, push it 7 days forward
2. **Daily recurring**: Single trigger with `RepeatFrequency.DAILY`
   - `skipCurrentCycle`: if today's trigger already passed, push it 24 hours forward
3. **Yearly**: One-time trigger at `dueDate + dueTime` (no YEARLY repeat in Notifee)
   - Auto-rescheduled on DELIVERED/DISMISSED by `rescheduleYearlyReminder()`
4. **One-time with date**: Single trigger at `dueDate + dueTime`
5. **Time only**: Next occurrence of `dueTime` (today if not passed, tomorrow otherwise)

### Yearly Reminder Reschedule

**Problem**: Notifee has no `RepeatFrequency.YEARLY`. Yearly reminders use one-time triggers.

**Solution**: `rescheduleYearlyReminder()` exists in BOTH `index.ts` (background) and `App.tsx` (foreground). On DELIVERED or DISMISSED:
1. Load reminder from storage
2. Check: is it `recurring` + has `dueDate` + no specific `days`? → yearly pattern
3. Cancel old notification IDs
4. Bump `dueDate` to next year (handles Feb 29 → Feb 28 on non-leap years)
5. Schedule new one-time trigger
6. Update reminder in storage

---

## 15. Sound Preview

**Function**: `previewSystemSound()` (`notifications.ts` line 720)

**How it works**:
1. Cancel any existing preview (`cancelSoundPreview()`)
2. Guard against rapid taps (`_previewCallId` counter)
3. Create a `preview_{mediaId}` channel with DEFAULT importance, `sound: soundUri`, no DND bypass
4. Fire a notification on that channel: title = sound name, body = "Sound preview"
5. Auto-cancel after 3 seconds via `setTimeout`

**Key detail**: Preview channels DO set `sound` (unlike alarm channels), because previews should respect ringer mode and play through the notification stream. This is intentional — previews don't need USAGE_ALARM behavior.

---

## Quick Reference: File Responsibilities

| File | Role in Notification System |
|------|-----------------------------|
| `plugins/withAlarmChannel.js` | Generates Java: AlarmChannelHelper (channels + MediaPlayer), AlarmChannelModule (RN bridge), AlarmChannelPackage |
| `plugins/withAlarmWake.js` | Injects wake flags into MainActivity: showWhenLocked, turnScreenOn, keepScreenOn, dismissKeyguard |
| `plugins/withNotifee.js` | Adds notification permissions to AndroidManifest |
| `src/services/notifications.ts` | All scheduling, channel creation, snooze, timer notifications, preview |
| `src/services/alarmSound.ts` | JS bridge to native MediaPlayer: play, stop, resolve URI |
| `src/services/pendingAlarm.ts` | Module-level data bridge (background → React) + notification dedupe map |
| `index.ts` | Background event handler: sound, pending data, one-time alarm deletion, yearly reschedule |
| `App.tsx` | Foreground event handler, init phase, onNavigationReady, AppState fallback, yearly reschedule |
| `src/screens/AlarmFireScreen.tsx` | Sound fallback, vibration, dismiss/snooze/guess why handlers, UI |
| `src/screens/OnboardingScreen.tsx` | Permission setup: notifications, exact alarm, battery, full-screen, Samsung DND, overlay |
| `src/utils/fullScreenPermission.ts` | Full-screen intent permission check (conservative false on API 34+) |
